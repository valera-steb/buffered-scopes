задача: реализовать observable и computed как в кнокауте.

на основе WeakMap




текущее:
.реализовать подписку на события.



вычислимые и наблюдаемые...
.observable:
  .можно подписаться на его изменение.
  .можно освободить - высвобождаться все подписки.
  .нужно как-то зафиксировать вызов - что-бы его можно было перехватить в computed.

.computed:
  .при создании получает функцию, которая вычисляет его значение.
  .в процессе вычисления подписываеться на все задетые observable.
  .при изменении одного из observable пересчитыват значение computed.

.в итоге, что я вижу?
  .два объекта связанны между собой.
  .одно дело - создать observable и потом к нему подписаться.
  .другое - computed в котором использован набор observable.
  .и 3-е - computed, в котором использованы другие computed.
=> есть инфраструктура, некий более общий объект, частями которого являються эти 2.

+ а мой разрез на области как повлияет на эту инфраструктуру?
  .ведь работа с областью превращаеться в неч-то похожее:
    .получить занчение - по вызову.
    .установить значение - вызов.
  + наличие основной части, у которой получаю скоупы, и которая контролирует их запуск.

  .другими словами, интерфейс может быть разширен 1-м методом - получить скоуп,
   и интерфейсом, в скоуп передаваемым (который даёт возможность создать внутренние вещи)


далее:
.добавить ди (di-light).
.поработать с фикстурой подмешиваемой через ди.
=> есть.


далее:
.надо описать подгрузку домена в тестах Computed/Observable.
+ разобраться как этой подгрузке задавать фикстуры по необходимости.
=> есть.



далее:
.есть набор картинок взаимодействия computed/observable/domain.
.я пока не могу выявить сценарии/управляющий_алгоритм.
.сделать фикстуру domainCore, которая будет:
    .использовать рабочие computed/observable.
    .реализовывать часть логики domainCore.
    .предназначена для уточнения сценария.
=> есть:
    .строгие ограничения.
    .прототип помог уточнить поведение для observable.
    .Computed на основе прототипа.



.далее:
    .дописать тесты/сценарии прототипа (3+1).
.после:
    .перенести код прототипа в domainCore.
    .оценить необходимость:
        .полезность сценариев в прототипе.
        + что могу тестировать в domainCore - а точнее фикстуры чего там делать.
        + могу ли тесты их domainProto разложить по другим файлам тестов?
        .сделать оббёртку поверх domainCore, которую использовать в сценариях.
.итого:
    .в прототипе ядра обрисовалась модель - довольно сложная, со своей логикой.
        .domainModel + domainInterfaces.
        .ведь по существу эти две вещи у меня.

    + тогда тестировать мне надо domainModel, подкидывая ей последовательности вызовов
    через интерфейсы...

    !!! что-же такое я тут вижу?
        .путь разработки.
        .тестирование через сценарии
            .ведь в части тестов прототипа, я смотрел на лог, оценивал его и переносил
            полученное значение в ожидание результата теста.

            .т.е. собранный код говорил что по его мнению должно быть, а я лишь проверял.
            + если-бы меня ответ насторожил - переписывал-бы.

            .возможно ли подобное, если я не буду запускать сценарии ? - нет,
            ведь не будет взаимодействий которые логировать.

=> требование уточнить работу require_for_di-lite и privateScopeWrapper
    .должен подгружать все приватные скоупы подгружать - так и есть, но нет регистрации.
    .должен ожидание внутренних скоупов собирать вместе и превращать в единый промайс
        - вызываеться с функцией загрузки один раз.
    .должен позволять оббёртке (privateScopeWrapper-у) указывать как она будет вести себя в родительском скоупе.
    .подмешивать прокси/оббёртку поверх заданных типов.

+ миграция на новый require_for_di-lite.




.далее:
    .закончить разбиение на domainModel + domainInterfaces с тестами по отдельности:
        .юнит для модели.
        .функциональные для ...
        .и интеграционные в сценариях.